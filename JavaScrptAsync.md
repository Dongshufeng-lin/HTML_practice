# setTimeout() 倒计时为什么会出现误差？
首先，JavaScript 是单线程，同一时间只能做一件事情


如果前面一个任务执行时间很长（比如网络请求），后面就必须的等待很长时间。为了解决这个问题，JavaScript 分为同步任务和异步任务。

先执行`同步任务`，执行完后，才会去执行`异步任务`，`异步任务`一般放在`异步队列`中。也就是执行完同步任务后，会不断从异步队列中取出要执行的任务放在主栈中执行，这个过程就称为`event-loop`


异步队列分为`宏任务队列`和`微任务队列`


`宏任务队列`包括：
1. setTimeout
2. setInterval
3. setImmediate

`微任务队列`包括：

1. promise
2. async/await


`微任务队列`执行顺序**大于**`宏任务队列`


所以，setTimeout 出现误差是因为：

1. 要先执行同步任务，才会执行异步任务；
2. 异步任务中，微任务执行顺序大于宏任务执行顺序。
3. 主线程对任务队列的读取及执行等过程

# 我的问题是：setTimeout() 里面计时因为执行同步任务，再执行异步任务，异步任务里微任务宏任务区分先后导致计时不准确，那么setTimeout 里面的这个时间用在那里是准确的？

第二个参数仅仅表示最少延迟时间，而非确切的等待时间；
这个参数代表了消息被实际加入到队列的最小延迟时间



# 单线程与事件循环

`JavaScript`是单线程语言。在浏览器中，当`JavaScript`代码被加载时，浏览器会为其分配一个主线程来执行任务，主线程会在栈中创建一个全局执行环境 （全局作用域）。每当有一个函数进入执行流时，就会形成一个对应的执行环境（函数作用域），并将该执行环境压入栈中。每当一个函数执行完毕以后，对应的执行环境就会从栈中弹出，然后被销毁。这就是执行环境栈，执行环境栈的作用就是保证所有的函数能按照正确的顺序被执行。


但在浏览器中，有一些任务是非常耗时的，比如 ajax请求、定时器、事件等。为了保证主线程上的任务不被阻塞，`JavaScript`内部维护了一个任务队列， 当这些耗时任务结束时（Ajax 请求返回、定时器超时、事件被触发），就将对应的回调函数插入队列中进行等待。这些任务的执行时机并不确定，只有当所有同步任务执行完毕后，执行环境栈被清空（栈底的全局执行环境会一直存在，直到进程退出）以后，然后再从任务队列中依次读取回调函数，并将其压入执行环境栈中。于是，主线程开始执行新的同步任务，执行完毕后再从栈中弹出，栈被清空。


主线程从任务队列中读取任务是不断循环的，每当栈被清空后，主线程就会从任务队列中读取新的任务并执行，如果没有新的任务，就会一直等待，直到有新的任务。JavaScript 的这种执行机制就叫做任务循环。因为每个任务都由一个事件所触发，所以也叫 “事件循环”。